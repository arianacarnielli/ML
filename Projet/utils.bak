# -*- coding: utf-8 -*-
"""
Created on Sun May 10 21:42:43 2020

@author: arian
"""

import matplotlib.pyplot as plt
import matplotlib.colors as clr
import numpy as np

from sklearn.linear_model import Lasso

class Image:
    """
    """
    
    def __init__(self, filename = None, patch = None):
        """
        """
        if patch is not None:
            self.img = patch[0]
            self.noise = patch[1]
        else:
            self._from_file(filename)
        
    def _from_file(self, filename):
        """
        """
        img = plt.imread(filename)
    
        # Si l'image a été lue comme des entiers, on la convertit en floats
        # dans [0, 1]
        if np.issubdtype(img.dtype, np.integer):
            info = np.iinfo(img.dtype)
            img = (img - info.min)/(info.max - info.min)
        
        # On convertit l'image en hsv avec entrées dans [0, 1]
        img = clr.rgb_to_hsv(img)
        
        # On la convertit à des entrées dans [-1, 1]
        self.img = 2*img - 1
        
        # Tableau de bruit initialisé à True (pas de bruit)
        self.noise = np.ones(self.img.shape[:2], dtype=bool)
    

    def show(self):
        """
        """
        
        # Conversion vers entrées en [0, 1]
        new_im = (self.img + 1)/2
        
        # Conversion vers rgb
        new_im = clr.hsv_to_rgb(new_im)
        
        # Conversion en noir des parties bruitées
        new_im *= self.noise.reshape(self.noise.shape[0],\
                                     self.noise.shape[1], 1)
        
        plt.imshow(new_im)
    
    def get_patch(self, i, j, h):
        """
        (i, j) : coordonnées du point au centre
        """
        imin = i - (h//2)
        jmin = j - (h//2)
        return self.img[imin:imin+h, jmin:jmin+h, :],\
               self.noise[imin:imin+h, jmin:jmin+h]
               
    def set_noise(self, p):
        """
        """
        self.noise = np.random.random(self.img.shape[:2]) > p
        
    def add_noise_rect(self, p, i, j, height, width):
        """
        """
        imin = i - (height//2)
        jmin = j - (width//2)
        noise_zone = self.noise[imin:(imin+height), jmin:(jmin+width)]
        noise_zone *= np.random.random(noise_zone.shape) > p
    
    def delete_rect(self, i, j, height, width):
        """
        (i, j) : coordonnées du point au centre
        """
        imin = i - (height//2)
        jmin = j - (width//2)
        self.noise[imin:(imin+height), jmin:(jmin+width)] = False
        
    def get_patches_and_atoms(self, h, step):
        """
        """
        patches = {}
        atoms = {}
        for i in range(h//2, self.img.shape[0] - (h//2), step):
            for j in range(h//2, self.img.shape[1] - (h//2), step):
                p = self.get_patch(i, j, h)
                if np.all(p[1]):
                    atoms[(i, j)] = p
                else:
                    patches[(i, j)] = p
        return patches, atoms

def patch_to_vect(patch):
    """
    """
    noise = np.empty(patch[0].shape, dtype=patch[1].dtype)
    for i in range(patch[0].shape[2]):
        noise[:, :, i] = patch[1]
    
    return patch[0].reshape(-1), noise.reshape(-1)

def vect_to_patch(vect):
    """
    """
    h = int(np.sqrt(vect[0].size//3))
    return vect[0].reshape(h, h, 3), vect[1].reshape(h, h, 3)[:, :, 0]

def learn_w(atoms, patch, alpha = 1.0):
    """
    """
    Y, mask = patch_to_vect(patch)
    list_keys = list(atoms.keys())
    X = np.empty((Y.size, len(list_keys)))
    for i, k in enumerate(list_keys):
        X[:, i], _ = patch_to_vect(atoms[k])
        
    lasso = Lasso(alpha = alpha, fit_intercept = True, max_iter = 20000)
    lasso.fit(X[mask, :], Y[mask])
    
    #w0 = lasso.intercept_
    w = lasso.coef_
    
    new_patch0 = Y.copy()
    new_patch0[np.logical_not(mask)] = lasso.predict(X[np.logical_not(mask), :])
    
    new_patch = vect_to_patch((new_patch0, np.ones(new_patch0.shape, dtype=bool)))
    
    return {k:w[i] for i, k in enumerate(list_keys)}, new_patch


if __name__=="__main__":
    #pass
    #img = Image("Images_Test/Peppers.tiff")
    
    #img = Image("Images_Test/Paris.jpg")
    #img.show()
    #img.add_noise_rect(0.5, 256, 256, 50, 50)
    #img.show()
    #patches, atoms = img.get_patches_and_atoms(10, 10)
    
    plt.close("all")
    
    img = Image("Images_Test/Bliss_Windows_XP.png")
    plt.figure()
    img.show()
    
    p0 = img.get_patch(130, 130, 20)
    ip0 = Image(patch = p0)
    plt.figure()
    ip0.show()
    
    img.delete_rect(150, 150, 40, 40)
    patches, atoms = img.get_patches_and_atoms(20, 20)
    
    p1 = patches[(130, 130)]
    ip1 = Image(patch = p1)
    plt.figure()
    ip1.show()
    
    w, p2 = learn_w(atoms, p1, 1e-2)
    
    ip2 = Image(patch = p2)
    plt.figure()
    ip2.show()